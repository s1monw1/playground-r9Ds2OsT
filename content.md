# Kotlin Reified Types in Inline Functions!

_Disclaimer: My articles are published under 
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode" target="_blank">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</a>._

© Copyright: Simon Wirtz, 2017
https://blog.simon-wirtz.de/kotlin-reified-types/

Feel free to share.

## Intro

I've noticed that many people haven't ever heard of reified types or have problems understanding what they are and what they do. Therefore this little post is intended to bring some light into the darkness of **Kotlin's reified types**.

## Starting situation

```kotlin
fun <T> myGenericFun(c: Class<T>)
```

In an ordinary generic function like `myGenericFun` you can't access the type `T` because it's, like in Java, *erased at runtime* and thus only available at compile time.  Therefore, if you want to use the generic type as a normal `Class` in the function body you need to explicitly pass the class as a parameter like the parameter `c` in the example. That's correct and works fine but makes it a bit unsightly for the caller.

### Inlined function with reified to the rescue

If, on the other hand, you use an `inline` function with a `reified` generic type `T`, the value of `T` can be accessed even at runtime and thus you don't need to pass the `Class<T>` in addition. You can work with `T` as if it was a normal `Class`, e.g. you might want to check whether a variable is an instance of `T`, which you can easily do like this: `myVar is T`.

An inline function with reified type looks like this:

```kotlin
inline fun <reified T> myGenericFun()
```

Be aware, that reified types can only be used in combination with inline functions. Such an inline function makes the compiler copy the function's bytecode into every place where the function is being called (we say the function is being "inlined"). **When you call an inline function with reified type, the compiler knows the actual type used as a type argument and modifies the generated bytecode to use the corresponding class directly.** Therefore calls like `myVar is T` become `myVar is String` (if the type argument were ``String``) in the bytecode and at runtime.

## Reified in Action

Let's have a look at an example, where reified is really helpful. We want to create an extension function for `String` called `toKotlinObject`, which tries to convert a JSON string to a Kotlin Object, specified by the function's type `T`. We can use `com.fasterxml.jackson.module.kotlin` for this and the first approach is the following:

```kotlin
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper

fun <T : Any> String.toKotlinObject(): T {
    val mapper = jacksonObjectMapper()
    //does not compile!
    return mapper.readValue(this, T::class.java)
}
```

The `readValue` function wants us to provide the information which type it's supposed to parse the `String` to. We try to use the type parameter `T` and get its `Class`. This does not work and the compiler tells us: **"Cannot use 'T' as reified type parameter. Use a class instead."**

### Working example without reified

```kotlin
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import kotlin.reflect.KClass

data class SimpleText(val simple: String)

fun main(args: Array<String>) {
    val asObject = """{"simple": "text"}""".toKotlinObject(SimpleText::class)
    println(asObject)
}

fun <T : Any> String.toKotlinObject(c: KClass<T>): T {
    val mapper = jacksonObjectMapper()
    return mapper.readValue(this, c.java)
}
```

In a next step we pass the `KClass` of `T` explicitly which can directly be used as an argument to `readValue`. This works and is actually the same approach used in Java code for such scenarios. The function can be called like so:

### With reified

Using an `inline` function with `reified` type parameter `T` makes it possible to implement our function as follows:

```kotlin
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper

data class SimpleText(val simple: String)

fun main(args: Array<String>) {
    val asObject = """{"simple": "text"}""".toKotlinObject<SimpleText>()
    println(asObject)
}

inline fun <reified T> String.toKotlinObject(): T {
    val mapper = jacksonObjectMapper()
    return mapper.readValue(JsonObject(this).encode(), T::class.java)
}
```

No need to pass the `KClass` of `T` additionally, `T` can be used as if it was an ordinary class. It's important to know, that `inline` functions with `reified` types are not callable from Java code, whereas normal `inline` functions are. That's probably the reason why not every type parameter used in `inline` functions is `reified` by default.

## Conclusion

This was just a quick introduction to `reified` types. In my opinion the call to a function with `reified` types looks way better because we can make use of the `<>` syntax commonly used whenever generics are relevant. As a result, it's more readable than the Java approach of passing a `Class` object as a parameter. All the dirty details can be read in this [specification](https://github.com/JetBrains/kotlin/blob/master/spec-docs/reified-type-parameters.md) document.

If you want to read more about Kotlin's beautiful features I recommend the book [Kotlin in Action](https://www.amazon.de/gp/product/1617293296/ref=as_li_tl?ie=UTF8&camp=1638&creative=6742&creativeASIN=1617293296&linkCode=as2&tag=simonwirtzde-21&linkId=0aacf80e18c7cea57cc77f7556eef2d2) to you and also like to direct you to my [other articles](https://blog.simon-wirtz.de) :)

Happy Kotlin coding!

